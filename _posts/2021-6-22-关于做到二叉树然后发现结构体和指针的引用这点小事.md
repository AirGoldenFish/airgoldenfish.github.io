---
title: 关于做到二叉树然后发现结构体和指针的引用这点小事
date: 2021-6-22
description: 本来是二叉树的题目，发现了结构体和指针的引用知识盲区，我精通C++啦（bushi）
category: 代码，要优雅
tags: 
  - C++
---
  # 指针的引用
  # struck
  ## 最最基础的struck理论
  C++中`struck`和`class`非常相似。类成员默认是私有的，结构体默认是公开的。可以把struck看作是轻量级的类。  
  
  声明的struck会和int、char等一样，成为一种数据类型。
  ```c++
#include<iostream>
using namespace std;
struct student
{
    int age=18;
    string name;
};
int main()
{
	student s1;
    cout<<s1.age<<endl;
    s1.age=17;
	s1.name="liliang";
    cout<<s1.age<<' '<<s1.name<<endl;
}
  ```
  在这个例子中，我们定义了一个student结构体，其属性有int类型的`age`和string类型的`name`，我们在主函数中创建了一个student类型的s1，他有属性年龄和名字。  
  
  在结构体中我们定义了`age`为18，之后又在s1中重新定义了`age`为17，可以看到被重定义为17
  
  输出结果为：
  ```
18
17 liliang
  ```
  ## 其他方法创建的变量（对象）
  上面说过，struck创建的是一个等同于int、char等的一个类型，所以具体的对象叫做变量。不过我还是想把它当成class里的对象。
  ### 跟在结构体后面的变量
  ```c++
#include<iostream>
#include<string>
#include <typeinfo>
using namespace std;
struct student
{
    int age;
    string name;
}s2;
int main()
{
    s2.age=18;
    s2.name="zhangzhen";
    cout<<s2.age<<' '<<s2.name<<endl;
}
  ```
  这里的s2就和上个例子中的s1是平等的，都是一个变量。程序输出结果为：
```
18 zhangzhen
```
### 指针变量
用`struckname *s=new struckname`创建一个指针变量s。
```c++
#include<iostream>
#include<string>
#include <typeinfo>
using namespace std;
struct student
{
    int age;
    string name;
}s2;
int main()
{
    s2.age=18;
    s2.name="zhangzhen";
    cout<<s2.age<<' '<<s2.name<<endl;
    student *s3=new student;
    s3->age=19;
    (*s3).name="duhaodong";
    cout<<s3->age<<' '<<s3->name<<endl;
    cout<<typeid(s2).name()<<endl;
    cout<<typeid(s3).name()<<endl;
}
```
我们用`cout<<typeid().name()<<endl;`分别查看s2和s3的类型（注意头文件`#include <typeinfo>`)
输出结果如下：
```
18 zhangzhen
19 duhaodong
7student
P7student
```
可以看出s2的类型是`student`（前面的7代表名字长度是7），而s3的类型是`Pstudent`，是一个指针。

在本例种中，用了两种方式对s3属性进行操作，`s3->age`和`(*s3).name`

另外一种使用指针对象的方法是跟在struck大括号后面
```
#include<iostream>
#include<string>
using namespace std;
struct student
{
    int age;
    string name;
}*s4;
int main()
{
    s4=new student;
    s4->age=3;
    s4->name="baobao";
    cout<<s4->age<<' '<<s4->name<<endl;
}
```
输出结果为
```
3 baobao
```
注意，这里的s4一定要用`s4=new student`初始化，初始化，初始化！不然没有分配内存

我们可以验证一下
```c++
#include<iostream>
#include<string>
using namespace std;
struct student
{
    int age;
    string name;
}*s4;
int main()
{
    cout<<s4<<endl;
    s4=new student;
    cout<<s4<<endl;
}
```
输出结果为
```
0
0xdc1c00
```
而在二叉树的这个题中，使用了`*s4=NULL`的用法，其实和只用`*s4`是一样的
```c++
#include<iostream>
#include<string>
using namespace std;
struct student
{
    int age;
    string name;
}*s4=NULL;
int main()
{
    cout<<s4<<endl;
    s4=new student;
    cout<<s4<<endl;
}
```
我们看一下地址：
```
0
0xd41c00
```
可以发现在声明之前是没有地址的（后面的地址不一样是因为分配的不一样，每次运行都会重新分配）


  